{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/ppro/ppro-utils.ts","../../../src/jsx/ppro/ppro.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\n\nconst config: CEP_Config = {\n  version,\n  id: \"com.dry-bones.cep\",\n  displayName: \"Dry Bones\",\n  symlink: \"local\",\n  port: 3000,\n  servePort: 5000,\n  startingDebugPort: 8860,\n  extensionManifestVersion: 6.0,\n  requiredRuntimeVersion: 9.0,\n  hosts: [\n    { name: \"PPRO\", version: \"[0.0,99.9]\" }\n  ],\n  type: \"Panel\",\n  iconDarkNormal: \"./src/assets/light-icon.png\",\n  iconNormal: \"./src/assets/dark-icon.png\",\n  iconDarkNormalRollOver: \"./src/assets/light-icon.png\",\n  iconNormalRollOver: \"./src/assets/dark-icon.png\",\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\n  width: 500,\n  height: 550,\n\n  panels: [\n    {\n      mainPath: \"./main/index.html\",\n      name: \"main\",\n      panelDisplayName: \"Dry Bones\",\n      autoVisible: true,\n      width: 600,\n      height: 650,\n    },\n\n  ],\n  build: {\n    jsxBin: \"off\",\n    sourceMap: true,\n  },\n  zxp: {\n    country: \"US\",\n    province: \"CA\",\n    org: \"MyCompany\",\n    password: \"mypassword\",\n    tsa: \"http://timestamp.digicert.com/\",\n    sourceMap: false,\n    jsxBin: \"off\",\n  },\n  installModules: [],\n  copyAssets: [],\n  copyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\r\nexport const ns = config.id;\r\nexport const displayName = config.displayName;\r\nexport const version = config.version;\r\n\r\nexport type BinItem = {\r\n    name: string;\r\n    id: string;\r\n    prefixCount: number;\r\n}\r\n\r\n// Count the number of characters prefixing a line in the editor\r\n// Thanks, StackOverflow\r\nexport const countConsecPrefixChars = (str: string, char: string) => {\r\n    let count = 0;\r\n    if (str[0] === char) {\r\n        count++;\r\n    } else {\r\n        return count;\r\n    }\r\n    let prevChar = str[0];\r\n    for (let i = 1; i < str.length; i++) {\r\n        if (str[i] === prevChar) {\r\n            count++;\r\n        } else {\r\n            break;\r\n        }\r\n        prevChar = str[i];\r\n    }\r\n    return count; \r\n};","// General Helpers\r\n\r\nexport const alertUser = (message: string) => {\r\n  alert(message);\r\n}\r\n\r\n// ProjectItem Helpers\r\n\r\nexport const forEachChild = (\r\n  item: ProjectItem,\r\n  callback: (item: ProjectItem) => void\r\n) => {\r\n  const len = item.children.numItems;\r\n  for (let i = 0; i < len; i++) {\r\n    callback(item.children[i]);\r\n  }\r\n};\r\n\r\nexport const deleteItem = (item: ProjectItem) => {\r\n  if (item.type === 2 /* BIN */) {\r\n    item.deleteBin();\r\n  } else {\r\n    const tmpBin = app.project.rootItem.createBin(\"tmp\");\r\n    item.moveBin(tmpBin);\r\n    tmpBin.deleteBin();\r\n  }\r\n};\r\n\r\nexport const getChildByName = (item: ProjectItem, name: string) => {\r\n  for (let i = 0; i < item.children.numItems; i++) {\r\n    const child = item.children[i];\r\n    if (child.name === name) {\r\n      return child;\r\n    }\r\n  }\r\n};\r\n\r\n// Recursively search a given item, provided a nodeId\r\nexport const getItemById = (item: ProjectItem, id: string): ProjectItem | undefined => {\r\n  // alert(\"entered function w/ \" + item.name + \"\\nid is \" + item.nodeId);\r\n  if (item === undefined) {\r\n      // alert(\"case 1: returning undefined\");\r\n      return undefined;\r\n  }\r\n  if (item.nodeId === id) {\r\n      // alert(\"case 2: returning item\");\r\n      return item;\r\n  }\r\n  if (item.type === 2 || item.type === 3) { // only Search BINs and ROOT\r\n      // alert(\"case 3: entering for loop on \" + item.name + \"'s children\");\r\n      for (let i = 0; i < item.children.numItems; i++) {\r\n          const child = item.children[i];\r\n          const result = getItemById(child, id);\r\n          if (result !== undefined) {\r\n              return result;\r\n          }\r\n      }\r\n  }\r\n  // alert(\"case 4: returning undefined\");\r\n  return undefined;\r\n};\r\n\r\n// Recursively search a given item, provided a name\r\nexport const getItemByName = (item: ProjectItem, name: string): ProjectItem | undefined => {\r\n  // alert(\"entered function w/ \" + item.name + \"\\nid is \" + item.nodeId);\r\n  if (item === undefined) {\r\n      // alert(\"case 1: returning undefined\");\r\n      return undefined;\r\n  }\r\n  if (item.name === name) {\r\n      // alert(\"case 2: returning item\");\r\n      return item;\r\n  }\r\n  if (item.type === 2 || item.type === 3) { // only Search BINs and ROOT\r\n      // alert(\"case 3: entering for loop on \" + item.name + \"'s children\");\r\n      for (let i = 0; i < item.children.numItems; i++) {\r\n          const child = item.children[i];\r\n          const result = getItemByName(child, name);\r\n          if (result !== undefined) {\r\n              return result;\r\n          }\r\n      }\r\n  }\r\n  // alert(\"case 4: returning undefined\");\r\n  return undefined;\r\n};\r\n\r\n// Print the name and id for children of an Item\r\nexport const printChildren = (item: ProjectItem) => {\r\n  let result = \"\";\r\n  for (let i = 0; i < item.children.numItems; i++) {\r\n      const child = item.children[i];\r\n      result += (child.name + \": \" + child.nodeId);\r\n      if (i !== (item.children.numItems - 1)) {\r\n          result += \", \";\r\n      }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport const getParentItem = (item: ProjectItem) => {\r\n  const dir = item.treePath.split(\"\\\\\");\r\n  if (dir.length < 2) {\r\n    return app.project.rootItem;\r\n  }\r\n  let current = app.project.rootItem;\r\n  for (let i = 2; i < dir.length - 1; i++) {\r\n    const name = dir[i];\r\n    const next = getChildByName(current, name);\r\n    if (next) {\r\n      current = next;\r\n    }\r\n  }\r\n  return current;\r\n};\r\n\r\nexport const findItemByPath = (\r\n  item: ProjectItem,\r\n  path: string\r\n): ProjectItem | undefined => {\r\n  const len = item.children.numItems;\r\n  for (let i = 0; i < len; i++) {\r\n    const child = item.children[i];\r\n    if (child.children && child.children.numItems > 0) {\r\n      const res = findItemByPath(child, path);\r\n      if (res) {\r\n        return res;\r\n      }\r\n    } else if (child.getMediaPath() === path) {\r\n      return child;\r\n    }\r\n  }\r\n};\r\n\r\n// Sequence Helpers\r\n\r\nexport const getSequenceLengthInFrames = (seq: Sequence) => {\r\n  const settings = seq.getSettings();\r\n  const end = seq.end;\r\n  const fps = settings.videoFrameRate.ticks;\r\n  const frames = parseInt(end) / parseInt(fps);\r\n  return frames;\r\n};\r\n\r\nexport const forEachVideoTrack = (\r\n  sequence: Sequence,\r\n  callback: (track: Track, index: number) => void,\r\n  reverse?: boolean\r\n) => {\r\n  const num = sequence.videoTracks.numTracks;\r\n  if (reverse) {\r\n    for (let i = num - 1; i > -1; i--) {\r\n      callback(sequence.videoTracks[i], i);\r\n    }\r\n  } else {\r\n    for (let i = 0; i < num; i++) {\r\n      callback(sequence.videoTracks[i], i);\r\n    }\r\n  }\r\n};\r\n\r\nexport const forEachAudioTrack = (\r\n  sequence: Sequence,\r\n  callback: (track: Track, index: number) => void,\r\n  reverse?: boolean\r\n) => {\r\n  const num = sequence.audioTracks.numTracks;\r\n  if (reverse) {\r\n    for (let i = num - 1; i > -1; i--) {\r\n      callback(sequence.audioTracks[i], i);\r\n    }\r\n  } else {\r\n    for (let i = 0; i < num; i++) {\r\n      callback(sequence.audioTracks[i], i);\r\n    }\r\n  }\r\n};\r\n\r\nexport const forEachClip = (\r\n  track: Track,\r\n  callback: (clip: TrackItem, index: number) => void,\r\n  reverse?: boolean\r\n) => {\r\n  const num = track.clips.numItems;\r\n  if (reverse) {\r\n    for (let i = num - 1; i > -1; i--) {\r\n      callback(track.clips[i], i);\r\n    }\r\n  } else {\r\n    for (let i = 0; i < num; i++) {\r\n      callback(track.clips[i], i);\r\n    }\r\n  }\r\n};\r\n\r\n// Time Helpers\r\n\r\nexport const addTime = (a: Time, b: Time) => {\r\n  const ticks = parseInt(a.ticks) + parseInt(b.ticks);\r\n  let time = new Time();\r\n  time.ticks = ticks.toString();\r\n  return time;\r\n};\r\n\r\nexport const subtractTime = (a: Time, b: Time) => {\r\n  const ticks = parseInt(a.ticks) - parseInt(b.ticks);\r\n  let time = new Time();\r\n  time.ticks = ticks.toString();\r\n  return time;\r\n};\r\nexport const multiplyTime = (a: Time, factor: number) => {\r\n  const ticks = parseInt(a.ticks) * factor;\r\n  let time = new Time();\r\n  time.ticks = ticks.toString();\r\n  return time;\r\n};\r\nexport const divideTime = (a: Time, factor: number) => {\r\n  const ticks = parseInt(a.ticks) / factor;\r\n  let time = new Time();\r\n  time.ticks = ticks.toString();\r\n  return time;\r\n};\r\n\r\n// QE DOM Methods\r\n\r\nexport const qeGetClipAt = (track: Track, index: number) => {\r\n  let curClipIndex = -1;\r\n  for (let i = 0; i < track.numItems; i++) {\r\n    const item = track.getItemAt(i);\r\n    //@ts-ignore\r\n    const type = item.type as \"Empty\" | \"Clip\";\r\n    if (type === \"Clip\") {\r\n      curClipIndex++;\r\n      if (curClipIndex === index) {\r\n        return item;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Metadata Helpers\r\n\r\nexport const getPrMetadata = (projectItem: ProjectItem, fields: string[]) => {\r\n  let PProMetaURI = \"http://ns.adobe.com/premierePrivateProjectMetaData/1.0/\";\r\n  if (ExternalObject.AdobeXMPScript === undefined) {\r\n    ExternalObject.AdobeXMPScript = new ExternalObject(\"lib:AdobeXMPScript\");\r\n  }\r\n  if (!app.isDocumentOpen() || !ExternalObject.AdobeXMPScript || !XMPMeta) {\r\n    return {};\r\n  }\r\n  let xmp = new XMPMeta(projectItem.getProjectMetadata());\r\n  let result: {\r\n    [key: string]: string;\r\n  } = {};\r\n  for (let i = 0; i < fields.length; i++) {\r\n    if (xmp.doesPropertyExist(PProMetaURI, fields[i])) {\r\n      result[fields[i]] = xmp.getProperty(PProMetaURI, fields[i]).value;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n// Motion Graphics Template ( MOGRT ) Helpers\r\n\r\nexport const fillMogrtText = (\r\n  clip: TrackItem,\r\n  propName: string,\r\n  text: string\r\n) => {\r\n  const mgt = clip.getMGTComponent();\r\n  const prop = mgt.properties.getParamForDisplayName(propName);\r\n  if (prop) {\r\n    const valueStr = prop.getValue();\r\n    let value = JSON.parse(valueStr) as any;\r\n    value.textEditValue = text;\r\n    prop.setValue(JSON.stringify(value), true);\r\n  }\r\n};\r\n\r\n// Audio Conversions\r\n\r\nexport const dbToDec = (x: number) => Math.pow(10, (x - 15) / 20);\r\n\r\nexport const decToDb = (x: number) => 20 * Math.log(x) * Math.LOG10E + 15;\r\n","import {\r\n    alertUser,\r\n    getItemById,\r\n    getItemByName,\r\n    printChildren\r\n} from \"./ppro-utils\";\r\nexport { alertUser }\r\nimport { countConsecPrefixChars } from \"../../shared/shared\";\r\nimport type { BinItem } from \"../../shared/shared\";\r\n\r\n// Root for Premiere Project\r\nconst root = app.project.rootItem;\r\n\r\nexport const testFunc = () => {\r\n    // const item = getItemById(root, \"000f4253\");\r\n    const s: BinItem[] = [\r\n        {name: \"n1\", id: \"id1\", prefixCount: 0},\r\n        {name: \"n2\", id: \"id2\", prefixCount: 1},\r\n        {name: \"n3\", id: \"id3\", prefixCount: 1},\r\n        {name: \"n4\", id: \"id1\", prefixCount: 1},\r\n    \r\n    ]\r\n    const item = getStackParent(s, 1);\r\n    alert(String(item?.id));\r\n};\r\n\r\nexport const parseText = (text: string) => {\r\n    const lines = text.split(\"\\n\");\r\n    let stack: BinItem[] = []; // Stores top-level trees\r\n    for (let i = 0; i < lines.length; i++) {\r\n        let line = lines[i];\r\n        const prefixCount = countConsecPrefixChars(line, \"|\");\r\n        // Comment or empty line\r\n        if (line.charAt(0) === \"#\" || line === \"\") {\r\n            continue;\r\n        }\r\n        // Top-level bin\r\n        else if (line.charAt(0) !== \"|\") {\r\n            stack = [];\r\n            const topBin = root.createBin(line);\r\n            stack.push({\r\n                name: topBin.name,\r\n                id: topBin.nodeId,\r\n                prefixCount: prefixCount\r\n            });\r\n        }\r\n        // Sub-level bin\r\n        else if (line.charAt(0) === \"|\"){\r\n            let parent: ProjectItem;\r\n            // Remove prefix from bin name\r\n            const name = line.substring(prefixCount);\r\n            // Get parent BinItem from stack\r\n            const parentBinItem = getStackParent(stack, prefixCount);\r\n            if (parentBinItem !== undefined) {\r\n                parent = getItemById(root, parentBinItem.id)!;\r\n                const subBin = parent.createBin(name);\r\n                stack.push({\r\n                    name: subBin.name,\r\n                    id: subBin.nodeId,\r\n                    prefixCount: prefixCount\r\n                });\r\n            } else {\r\n                alert(`Error at line ${i+1}.\\n\"${line}\" will be skipped.`);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Look for most recent parent candidate in stack\r\nexport const getStackParent = (stack: BinItem[], count: number) => {\r\n    for (let i = stack.length - 1; i >= 0; i--) {\r\n        const storedItem = stack[i];\r\n        if (count - storedItem.prefixCount === 1) {\r\n            return storedItem;\r\n        } else {\r\n            continue;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport const printStack = (stack: BinItem[]) => {\r\n    let result = \"Stack:\\n\";\r\n    for (let i = 0; i < stack.length; i++) {\r\n        const item = stack[i];\r\n        result += `id: ${item.id}\\nname: ${item.name}\\nprefixCount: ${item.prefixCount}`;\r\n        if (i < stack.length - 1) {\r\n            result += \"\\n\\n\";\r\n        }\r\n    }\r\n    alert(result);\r\n}","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as ppro from \"./ppro/ppro\";\n\nlet main: any;\n\nswitch (BridgeTalk.appName) {\n  case \"premierepro\":\n  case \"premiereprobeta\":\n    main = ppro;\n    break;\n}\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\nhost[ns] = main;\n\nexport type Scripts = typeof ppro\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","parameters","width","height","panels","mainPath","panelDisplayName","autoVisible","build","jsxBin","sourceMap","zxp","country","province","org","password","tsa","installModules","copyAssets","copyZipAssets","count","prevChar","prefixCount","stack","result","main","host"],"mappings":";;AAIA;AACEA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACIC;AAAcV;AAAsB;AAExCW;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEAC;AAEIC;AACAV;AACAW;AACAC;AACAL;AACAC;AACF;AAGFK;AACEC;AACAC;;AAEFC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAN;AACAD;;AAEFQ;AACAC;AACAC;AACF;;ACpDA;AAUA;AACA;AACA;;AAEI;AACIC;AACJ;AACI;AACJ;AACA;AACA;AACI;AACIA;AACJ;AACI;AACJ;AACAC;AACJ;AACA;AACJ;;AC9BA;;AAEA;;AAEA;;AAiCA;AACA;AACE;;AAEI;AACA;AACJ;AACA;AACI;AACA;AACJ;;AAC0C;AACtC;AACA;AACI;AACA;;AAEI;AACJ;AACJ;AACJ;AACA;AACA;AACF;;AClDA;AACA;AAEA;AACI;;AAEK1B;AAAYT;AAAWoC;AAAc;AACrC3B;AAAYT;AAAWoC;AAAc;AACrC3B;AAAYT;AAAWoC;AAAc;AACrC3B;AAAYT;AAAWoC;AAAc;AAG1C;;AAEJ;AAEA;AACI;AACA;AACA;AACI;AACA;AACA;AACA;AACI;AACJ;AACA;;AAEIC;AACA;;;;AAIID;AACJ;AACJ;AACA;;AAEI;AACA;AACA;AACA;AACA;;;AAGI;;;;AAIIA;AACJ;AACJ;;AAEA;AACJ;AACJ;AACJ;;AAGA;AACA;AACI;AACI;AACA;AACI;AACJ;AACI;AACJ;AACJ;AACA;AACJ;AAEA;;AAEI;AACI;AACAE;AACA;AACIA;AACJ;AACJ;;AAEJ;;;;;;;;;;;ACtFA;AAEA;AACE;AACA;AACEC;AACA;AACJ;AACA;AACA;AACAC"}
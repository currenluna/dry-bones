{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/ppro/ppro-utils.ts","../../../src/jsx/ppro/ppro.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\n\nconst config: CEP_Config = {\n  version,\n  id: \"com.dry-bones.cep\",\n  displayName: \"Dry Bones\",\n  symlink: \"local\",\n  port: 3000,\n  servePort: 5000,\n  startingDebugPort: 8860,\n  extensionManifestVersion: 6.0,\n  requiredRuntimeVersion: 9.0,\n  hosts: [\n    { name: \"PPRO\", version: \"[0.0,99.9]\" }\n  ],\n  type: \"Panel\",\n  iconDarkNormal: \"./src/assets/light-icon.png\",\n  iconNormal: \"./src/assets/dark-icon.png\",\n  iconDarkNormalRollOver: \"./src/assets/light-icon.png\",\n  iconNormalRollOver: \"./src/assets/dark-icon.png\",\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\n  width: 500,\n  height: 550,\n\n  panels: [\n    {\n      mainPath: \"./main/index.html\",\n      name: \"main\",\n      panelDisplayName: \"Dry Bones\",\n      autoVisible: true,\n      width: 600,\n      height: 650,\n    },\n\n  ],\n  build: {\n    jsxBin: \"off\",\n    sourceMap: true,\n  },\n  zxp: {\n    country: \"US\",\n    province: \"CA\",\n    org: \"MyCompany\",\n    password: \"mypassword\",\n    tsa: \"http://timestamp.digicert.com/\",\n    sourceMap: false,\n    jsxBin: \"off\",\n  },\n  installModules: [],\n  copyAssets: [],\n  copyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\nexport const ns = config.id;\nexport const displayName = config.displayName;\nexport const version = config.version;\n\nexport type BinItem = {\n    name: string;\n    id: string;\n    prefixCount: number;\n}\n\n// Count the number of characters prefixing a line in the editor\n// Thanks, StackOverflow\nexport const countConsecPrefixChars = (str: string, char: string) => {\n    let count = 0;\n    if (str[0] === char) {\n        count++;\n    } else {\n        return count;\n    }\n    let prevChar = str[0];\n    for (let i = 1; i < str.length; i++) {\n        if (str[i] === prevChar) {\n            count++;\n        } else {\n            break;\n        }\n        prevChar = str[i];\n    }\n    return count; \n};","// General Helpers\n\nexport const alertUser = (message: string) => {\n  alert(message);\n}\n\n// ProjectItem Helpers\n\nexport const forEachChild = (\n  item: ProjectItem,\n  callback: (item: ProjectItem) => void\n) => {\n  const len = item.children.numItems;\n  for (let i = 0; i < len; i++) {\n    callback(item.children[i]);\n  }\n};\n\nexport const deleteItem = (item: ProjectItem) => {\n  if (item.type === 2 /* BIN */) {\n    item.deleteBin();\n  } else {\n    const tmpBin = app.project.rootItem.createBin(\"tmp\");\n    item.moveBin(tmpBin);\n    tmpBin.deleteBin();\n  }\n};\n\nexport const getChildByName = (item: ProjectItem, name: string) => {\n  for (let i = 0; i < item.children.numItems; i++) {\n    const child = item.children[i];\n    if (child.name === name) {\n      return child;\n    }\n  }\n};\n\n// Recursively search a given item, provided a nodeId\nexport const getItemById = (item: ProjectItem, id: string): ProjectItem | undefined => {\n  // alert(\"entered function w/ \" + item.name + \"\\nid is \" + item.nodeId);\n  if (item === undefined) {\n      // alert(\"case 1: returning undefined\");\n      return undefined;\n  }\n  if (item.nodeId === id) {\n      // alert(\"case 2: returning item\");\n      return item;\n  }\n  if (item.type === 2 || item.type === 3) { // only Search BINs and ROOT\n      // alert(\"case 3: entering for loop on \" + item.name + \"'s children\");\n      for (let i = 0; i < item.children.numItems; i++) {\n          const child = item.children[i];\n          const result = getItemById(child, id);\n          if (result !== undefined) {\n              return result;\n          }\n      }\n  }\n  // alert(\"case 4: returning undefined\");\n  return undefined;\n};\n\n// Recursively search a given item, provided a name\nexport const getItemByName = (item: ProjectItem, name: string): ProjectItem | undefined => {\n  // alert(\"entered function w/ \" + item.name + \"\\nid is \" + item.nodeId);\n  if (item === undefined) {\n      // alert(\"case 1: returning undefined\");\n      return undefined;\n  }\n  if (item.name === name) {\n      // alert(\"case 2: returning item\");\n      return item;\n  }\n  if (item.type === 2 || item.type === 3) { // only Search BINs and ROOT\n      // alert(\"case 3: entering for loop on \" + item.name + \"'s children\");\n      for (let i = 0; i < item.children.numItems; i++) {\n          const child = item.children[i];\n          const result = getItemByName(child, name);\n          if (result !== undefined) {\n              return result;\n          }\n      }\n  }\n  // alert(\"case 4: returning undefined\");\n  return undefined;\n};\n\n// Print the name and id for children of an Item\nexport const printChildren = (item: ProjectItem) => {\n  let result = \"\";\n  for (let i = 0; i < item.children.numItems; i++) {\n      const child = item.children[i];\n      result += (child.name + \": \" + child.nodeId);\n      if (i !== (item.children.numItems - 1)) {\n          result += \", \";\n      }\n  }\n  return result;\n}\n\nexport const getParentItem = (item: ProjectItem) => {\n  const dir = item.treePath.split(\"\\\\\");\n  if (dir.length < 2) {\n    return app.project.rootItem;\n  }\n  let current = app.project.rootItem;\n  for (let i = 2; i < dir.length - 1; i++) {\n    const name = dir[i];\n    const next = getChildByName(current, name);\n    if (next) {\n      current = next;\n    }\n  }\n  return current;\n};\n\nexport const findItemByPath = (\n  item: ProjectItem,\n  path: string\n): ProjectItem | undefined => {\n  const len = item.children.numItems;\n  for (let i = 0; i < len; i++) {\n    const child = item.children[i];\n    if (child.children && child.children.numItems > 0) {\n      const res = findItemByPath(child, path);\n      if (res) {\n        return res;\n      }\n    } else if (child.getMediaPath() === path) {\n      return child;\n    }\n  }\n};\n\n// Sequence Helpers\n\nexport const getSequenceLengthInFrames = (seq: Sequence) => {\n  const settings = seq.getSettings();\n  const end = seq.end;\n  const fps = settings.videoFrameRate.ticks;\n  const frames = parseInt(end) / parseInt(fps);\n  return frames;\n};\n\nexport const forEachVideoTrack = (\n  sequence: Sequence,\n  callback: (track: Track, index: number) => void,\n  reverse?: boolean\n) => {\n  const num = sequence.videoTracks.numTracks;\n  if (reverse) {\n    for (let i = num - 1; i > -1; i--) {\n      callback(sequence.videoTracks[i], i);\n    }\n  } else {\n    for (let i = 0; i < num; i++) {\n      callback(sequence.videoTracks[i], i);\n    }\n  }\n};\n\nexport const forEachAudioTrack = (\n  sequence: Sequence,\n  callback: (track: Track, index: number) => void,\n  reverse?: boolean\n) => {\n  const num = sequence.audioTracks.numTracks;\n  if (reverse) {\n    for (let i = num - 1; i > -1; i--) {\n      callback(sequence.audioTracks[i], i);\n    }\n  } else {\n    for (let i = 0; i < num; i++) {\n      callback(sequence.audioTracks[i], i);\n    }\n  }\n};\n\nexport const forEachClip = (\n  track: Track,\n  callback: (clip: TrackItem, index: number) => void,\n  reverse?: boolean\n) => {\n  const num = track.clips.numItems;\n  if (reverse) {\n    for (let i = num - 1; i > -1; i--) {\n      callback(track.clips[i], i);\n    }\n  } else {\n    for (let i = 0; i < num; i++) {\n      callback(track.clips[i], i);\n    }\n  }\n};\n\n// Time Helpers\n\nexport const addTime = (a: Time, b: Time) => {\n  const ticks = parseInt(a.ticks) + parseInt(b.ticks);\n  let time = new Time();\n  time.ticks = ticks.toString();\n  return time;\n};\n\nexport const subtractTime = (a: Time, b: Time) => {\n  const ticks = parseInt(a.ticks) - parseInt(b.ticks);\n  let time = new Time();\n  time.ticks = ticks.toString();\n  return time;\n};\nexport const multiplyTime = (a: Time, factor: number) => {\n  const ticks = parseInt(a.ticks) * factor;\n  let time = new Time();\n  time.ticks = ticks.toString();\n  return time;\n};\nexport const divideTime = (a: Time, factor: number) => {\n  const ticks = parseInt(a.ticks) / factor;\n  let time = new Time();\n  time.ticks = ticks.toString();\n  return time;\n};\n\n// QE DOM Methods\n\nexport const qeGetClipAt = (track: Track, index: number) => {\n  let curClipIndex = -1;\n  for (let i = 0; i < track.numItems; i++) {\n    const item = track.getItemAt(i);\n    //@ts-ignore\n    const type = item.type as \"Empty\" | \"Clip\";\n    if (type === \"Clip\") {\n      curClipIndex++;\n      if (curClipIndex === index) {\n        return item;\n      }\n    }\n  }\n};\n\n// Metadata Helpers\n\nexport const getPrMetadata = (projectItem: ProjectItem, fields: string[]) => {\n  let PProMetaURI = \"http://ns.adobe.com/premierePrivateProjectMetaData/1.0/\";\n  if (ExternalObject.AdobeXMPScript === undefined) {\n    ExternalObject.AdobeXMPScript = new ExternalObject(\"lib:AdobeXMPScript\");\n  }\n  if (!app.isDocumentOpen() || !ExternalObject.AdobeXMPScript || !XMPMeta) {\n    return {};\n  }\n  let xmp = new XMPMeta(projectItem.getProjectMetadata());\n  let result: {\n    [key: string]: string;\n  } = {};\n  for (let i = 0; i < fields.length; i++) {\n    if (xmp.doesPropertyExist(PProMetaURI, fields[i])) {\n      result[fields[i]] = xmp.getProperty(PProMetaURI, fields[i]).value;\n    }\n  }\n  return result;\n};\n\n// Motion Graphics Template ( MOGRT ) Helpers\n\nexport const fillMogrtText = (\n  clip: TrackItem,\n  propName: string,\n  text: string\n) => {\n  const mgt = clip.getMGTComponent();\n  const prop = mgt.properties.getParamForDisplayName(propName);\n  if (prop) {\n    const valueStr = prop.getValue();\n    let value = JSON.parse(valueStr) as any;\n    value.textEditValue = text;\n    prop.setValue(JSON.stringify(value), true);\n  }\n};\n\n// Audio Conversions\n\nexport const dbToDec = (x: number) => Math.pow(10, (x - 15) / 20);\n\nexport const decToDb = (x: number) => 20 * Math.log(x) * Math.LOG10E + 15;\n","import {\n    alertUser,\n    getItemById,\n    getItemByName,\n    printChildren\n} from \"./ppro-utils\";\nexport { alertUser }\nimport { countConsecPrefixChars } from \"../../shared/shared\";\nimport type { BinItem } from \"../../shared/shared\";\n\n// Root for Premiere Project\nconst root = app.project.rootItem;\n\nexport const testFunc = () => {\n    // // const item = getItemById(root, \"000f4253\");\n    // const s: BinItem[] = [\n    //     {name: \"n1\", id: \"id1\", prefixCount: 0},\n    //     {name: \"n2\", id: \"id2\", prefixCount: 1},\n    //     {name: \"n3\", id: \"id3\", prefixCount: 1},\n    //     {name: \"n4\", id: \"id1\", prefixCount: 1},\n    \n    // ]\n    // const item = getStackParent(s, 1);\n    // alert(String(item?.id));\n\n};\n\nexport const parseText = (text: string) => {\n    const lines = text.split(\"\\n\");\n    let m = \"\";\n    for (let x = 0; x < lines.length; x++) {\n        m += lines[x];\n        m += \"\\n\";\n    }\n    alert(m);\n    let stack: BinItem[] = []; // Stores top-level trees\n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        const prefixCount = countConsecPrefixChars(line, \"|\");\n        // Comment or empty line\n        if (line.charAt(0) === \"#\" || line === \"\") {\n            continue;\n        }\n        // Top-level bin\n        else if (line.charAt(0) !== \"|\") {\n            stack = [];\n            const topBin = root.createBin(line);\n            stack.push({\n                name: topBin.name,\n                id: topBin.nodeId,\n                prefixCount: prefixCount\n            });\n        }\n        // Sub-level bin\n        else if (line.charAt(0) === \"|\"){\n            let parent: ProjectItem;\n            // Remove prefix from bin name\n            const name = line.substring(prefixCount);\n            // Get parent BinItem from stack\n            const parentBinItem = getStackParent(stack, prefixCount);\n            if (parentBinItem !== undefined) {\n                parent = getItemById(root, parentBinItem.id)!;\n                const subBin = parent.createBin(name);\n                stack.push({\n                    name: subBin.name,\n                    id: subBin.nodeId,\n                    prefixCount: prefixCount\n                });\n            } else {\n                alert(`Error at line ${i+1}.\\n\"${line}\" will be skipped.`);\n            }\n        }\n    }\n}\n\n\n// Look for most recent parent candidate in stack\nexport const getStackParent = (stack: BinItem[], count: number) => {\n    for (let i = stack.length - 1; i >= 0; i--) {\n        const storedItem = stack[i];\n        if (count - storedItem.prefixCount === 1) {\n            return storedItem;\n        } else {\n            continue;\n        }\n    }\n    return undefined;\n}\n\nexport const printStack = (stack: BinItem[]) => {\n    let result = \"Stack:\\n\";\n    for (let i = 0; i < stack.length; i++) {\n        const item = stack[i];\n        result += `id: ${item.id}\\nname: ${item.name}\\nprefixCount: ${item.prefixCount}`;\n        if (i < stack.length - 1) {\n            result += \"\\n\\n\";\n        }\n    }\n    alert(result);\n}","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as ppro from \"./ppro/ppro\";\n\nlet main: any;\n\nswitch (BridgeTalk.appName) {\n  case \"premierepro\":\n  case \"premiereprobeta\":\n    main = ppro;\n    break;\n}\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\nhost[ns] = main;\n\nexport type Scripts = typeof ppro\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","parameters","width","height","panels","mainPath","panelDisplayName","autoVisible","build","jsxBin","sourceMap","zxp","country","province","org","password","tsa","installModules","copyAssets","copyZipAssets","count","prevChar","m","stack","prefixCount","result","main","host"],"mappings":";;AAIA;AACEA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACIC;AAAcV;AAAsB;AAExCW;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEAC;AAEIC;AACAV;AACAW;AACAC;AACAL;AACAC;AACF;AAGFK;AACEC;AACAC;;AAEFC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAN;AACAD;;AAEFQ;AACAC;AACAC;AACF;;ACpDA;AAUA;AACA;AACA;;AAEI;AACIC;AACJ;AACI;AACJ;AACA;AACA;AACI;AACIA;AACJ;AACI;AACJ;AACAC;AACJ;AACA;AACJ;;AC9BA;;AAEA;;AAEA;;AAiCA;AACA;AACE;;AAEI;AACA;AACJ;AACA;AACI;AACA;AACJ;;AAC0C;AACtC;AACA;AACI;AACA;;AAEI;AACJ;AACJ;AACJ;AACA;AACA;AACF;;AClDA;AACA;AAEA;AACI;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAIJ;AACI;;AAEA;AACIC;AACAA;AACJ;;AAEA;AACA;AACI;AACA;AACA;AACA;AACI;AACJ;AACA;;AAEIC;AACA;;;;AAIIC;AACJ;AACJ;AACA;;AAEI;AACA;AACA;AACA;AACA;;;AAGI;;;;AAIIA;AACJ;AACJ;;AAEA;AACJ;AACJ;AACJ;;AAGA;AACA;AACI;AACI;AACA;AACI;AACJ;AACI;AACJ;AACJ;AACA;AACJ;AAEA;;AAEI;AACI;AACAC;AACA;AACIA;AACJ;AACJ;;AAEJ;;;;;;;;;;;AC7FA;AAEA;AACE;AACA;AACEC;AACA;AACJ;AACA;AACA;AACAC"}